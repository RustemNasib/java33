package lesson_19;

import java.util.HashSet;
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        /*
         *  Блок теории 1
         *  Коллекция - это массив с неограниченным размером и хранящий любые типы данных, но одного типа в одной коллекции
         *  До версии JDK 1.5 все коллекции были подчинены Object, и поэтому одна коллекция могла хранить разные типы
         *  данных, но не могла иметь разные методы свойственные типам и поэтому после от этого отказались и все коллекции
         *  стали содержать только один тип.
         *
         *       Интерфейсы коллекций: Collection и Map (находятся на одном уровне, т.е. друг с другом не связаны)
         *                             Collection - группы объектов;
         *                             Map - массив объектов по ассоциациям;
         *
         *                                      (Interface)
         *                                        Iterable (повторяемый или перебираемый) содержит Iterator<T> iterator();
         *                                           |
         *                                      (Interface)
         *               __________________java.util.Collection _________________________
         *              |                                                               |
         *          (Interface)                                                     (Interface)
         *      java.util.Set (Сумка)                                             java.util.List (Записная книжка)
         *      - Все значения уникальны;                                          - Могут хранится дубликаты значений;
         *      - Нет индексов;                                                    - Индексы есть;
         *      - Нет порядка вхождения;                                           - Есть порядок вхождения;
         *                  |                                                                        |
         *     _____________|_______________                                         ________________|___________________
         *     |                           |                                         |                                  |
         * (Interface)                HashSet                                   ArrayList                         LinkedList
         * SortedSet                - Элементы не упорядочены                 (ас.пронумерованный список)       (ас.живая очередь)
         *     |                    - Может хранить NULL – значения          - Добавление долго              - Добавление быстрое
         * (Interface)              - Порядок задает HashCode                - Удаление долго                - Удаление быстрое
         * NavigableSet                                |                     - Читать быстро                 - Читать дольше
         *     |                                       |                    ___________________              ___________________
         *     |                                       |                         - Удаление редкое;              - Удаление частое;
         *     |                                       |                     - Чтение частое;                - Чтение условно редкое;
         *     |                                       |
         *  TreeSet                              LinkedHashSet
         * - Порядок определяется compareTo()    - Есть порядок вхождения
         * - Часто исп. в сортировках для сайтов
         *
         */

    /*
         * Блок теории 2
         * Элементы внутри коллекции TreeSet организуются в виде бинарного дерева. Но больше похоже на корни дерева.
         * Есть голова и всегда только два корня поэтому и называется бинарное.
         * Предположим коллекцию чисел
         *    TreeSet<Integer> numbersTreeSet = new TreeSet<>();
         *         numbersTreeSet.add(8);
         *         numbersTreeSet.add(12);
         *         numbersTreeSet.add(4);
         *         numbersTreeSet.add(2);
         *         numbersTreeSet.add(5);
         *         numbersTreeSet.add(14);
         *         numbersTreeSet.add(9);
         *         numbersTreeSet.add(10);
         *         numbersTreeSet.add(7);
         *         numbersTreeSet.add(3);
         *
                 * Структура будет выглядеть так:(по-очереди большее число идет например вправо, а меньшее влево)
                           _________8(X)___________
         *                  |                    |
                   _______4(Y)_____        ______12_____
         *           |           |        |            |
                    2___         5___     9___        14
                           |            |        |
         *                 3            7        10
         *
         *  Метод отвечающий за распределение значений по веткам compareTo(), возвращает числа -x или 0 или +x
         *  0 - означает, что такой объект уже есть и сохранять его не нужно;
         *  отрицательное число - значит кладем влево;
         *  положительное число - значит кладем вправо;
         *
         *  Для стандартных классов метод compareTo() уже имеет реализацию.
         *  А для новых классов метод compareTo() необходимо реализовать. Интерфейс Comparable<>
         *
         *
         */

/**
 * Блок теории 3 HashCode
 * Представьте что вы коллекционер монет и у Вас уже есть коллекция монет из 10 000 штук.
 * Вам предложили новую монету, как быстро проверить есть ли так я же у вас или нет, ведь в коллекции
 * все монеты должны быть уникальный.
 * Можно быстро проверить по странам, по номиналу, по диаметру, год выпуска.
 * То есть нужны характеристики которые есть у каждой монеты.
 * И характеристика должна быть объективно определяемой, например цвет не пойдет.
 *
 * Совокупность характеристик может дать числовой код, который и покажет номер ячейки.
 * При этом у двух разных монеток могут быть разные хэшкоды, но у монет будут еще отличия, которые не вошли
 * в хэшкод, например цвет. Поэтому после отработки метода .hashcode должен отработать метод .equals и
 * окончательно сравнить монеты и вернуть boolean означающий есть такая монета в коллекции или нет.
 */

/**
 * Тернарный оператор: (условие)? true: false;
 *  метод
 *      public static int compare(int x, int y) { //x - это значение в коллекции, y - значение с которым сравниваем
 *               return (x < y) ? -1 : ((x == y) ? 0 : 1); (условие)? выполнить если true: выполнить если false;
 *        }
 *
 *
 */

// Создаем монеты
        Coin coin1 = new Coin(10, 20.2, "Russian", 2005);
        Coin coin2 = new Coin(5, 20.2, "Russian", 2005);
        Coin coin3 = new Coin(2, 12.0, "USSR", 1987);
        Coin coin4 = new Coin(5, 10.5, "China", 2020);
        Coin coin5 = new Coin(50, 15.2, "Kazakhstan", 2021);

        // кладем монеты в коллекцию
        TreeSet<Coin> coins = new TreeSet<>();
        coins.add(coin1);
        coins.add(coin2);
        coins.add(coin3);
        coins.add(coin4);
        coins.add(coin5);

        for (Coin c : coins) { // проход по коллекции
            System.out.println(c);// здесь выводится метод toString, который нужно переопределить в классе Coin
        }
        System.out.println("================================");
        Sort_Coins.printSortByYear(coins);
        System.out.println("================================");
        Sort_Coins.printSortToFrom(coins);
    }
}
